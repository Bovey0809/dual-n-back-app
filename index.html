<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dual N-Back Training</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
        }

        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 600px;
            width: 90%;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-weight: 300;
            font-size: 2.5em;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        label {
            font-weight: 500;
        }

        select, button {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        select:hover, button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        select:focus, button:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.3);
        }

        option {
            background: #333;
            color: white;
        }

        .game-area {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
            min-height: 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 30px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .grid.active {
            opacity: 1;
        }

        .square {
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .square.active {
            background: #4CAF50;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
            border-color: #4CAF50;
        }

        .square.clicked {
            background: #2196F3;
            border-color: #2196F3;
        }

        .audio-indicator {
            font-size: 3em;
            margin-bottom: 20px;
            opacity: 0;
            transition: all 0.3s ease;
            display: none; /* Hidden since we don't need visual letter display */
        }

        .audio-indicator.active {
            opacity: 1;
            transform: scale(1.2);
        }

        .instructions {
            text-align: center;
            margin-bottom: 20px;
            font-size: 18px;
            opacity: 0.8;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
            margin-bottom: 20px;
        }

        .records-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .records-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .records-title {
            font-size: 1.2em;
            font-weight: bold;
        }

        .clear-records-btn {
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid rgba(244, 67, 54, 0.4);
            color: white;
            padding: 5px 10px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .clear-records-btn:hover {
            background: rgba(244, 67, 54, 0.3);
        }

        .records-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .record-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            font-size: 0.9em;
            border-left: 3px solid #4CAF50;
        }

        .record-date {
            font-weight: bold;
            color: #4CAF50;
            margin-bottom: 5px;
        }

        .record-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 10px;
            font-size: 0.85em;
            opacity: 0.9;
        }

        .no-records {
            text-align: center;
            opacity: 0.6;
            font-style: italic;
            padding: 20px;
        }

        .stat-box {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .response-buttons {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        .response-btn {
            padding: 15px 25px;
            font-size: 16px;
            border-radius: 25px;
            font-weight: bold;
            min-width: 120px;
        }

        .response-btn.visual {
            background: linear-gradient(45deg, #FF6B6B, #FF8E8E);
        }

        .response-btn.audio {
            background: linear-gradient(45deg, #4ECDC4, #44A08D);
        }

        .response-btn:active {
            transform: scale(0.95);
        }

        .disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            margin-bottom: 15px;
            overflow: hidden;
        }

        .timer-display {
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
            opacity: 0.9;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #45a049);
            width: 0%;
            transition: width 0.3s ease;
        }

        .feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2em;
            font-weight: bold;
            padding: 20px 40px;
            border-radius: 15px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            display: none; /* Hidden since we're using audio feedback */
        }

        .feedback.correct {
            background: rgba(76, 175, 80, 0.9);
            color: white;
            border: 2px solid #4CAF50;
        }

        .feedback.incorrect {
            background: rgba(244, 67, 54, 0.9);
            color: white;
            border: 2px solid #f44336;
        }

        .feedback.show {
            opacity: 1;
        }

        .level-change-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: bold;
            z-index: 1000;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.5s ease;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .level-change-notification.show {
            opacity: 1;
            transform: translateX(0);
        }

        .level-change-notification.level-down {
            background: linear-gradient(45deg, #FF9800, #F57C00);
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .pulse {
            animation: pulse 0.5s ease-in-out;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 data-i18n="title">Dual N-Back Training</h1>
        
        <div class="controls">
            <div class="control-group">
                <label for="language" data-i18n="language">Language:</label>
                <select id="language">
                    <option value="en" data-i18n="lang-en">English</option>
                    <option value="zh" data-i18n="lang-zh">ä¸­æ–‡</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="nLevel" data-i18n="n-level">N-Level:</label>
                <select id="nLevel">
                    <option value="1" data-i18n="1-back">1-Back</option>
                    <option value="2" selected data-i18n="2-back">2-Back</option>
                    <option value="3" data-i18n="3-back">3-Back</option>
                    <option value="4" data-i18n="4-back">4-Back</option>
                    <option value="5" data-i18n="5-back">5-Back</option>
                    <option value="6" data-i18n="6-back">6-Back</option>
                    <option value="7" data-i18n="7-back">7-Back</option>
                    <option value="8" data-i18n="8-back">8-Back</option>
                    <option value="9" data-i18n="9-back">9-Back</option>
                    <option value="10" data-i18n="10-back">10-Back</option>
                    <option value="11" data-i18n="11-back">11-Back</option>
                    <option value="12" data-i18n="12-back">12-Back</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="speed" data-i18n="speed">Speed:</label>
                <select id="speed">
                    <option value="3000" data-i18n="slow">Slow (3s)</option>
                    <option value="2500" selected data-i18n="normal">Normal (2.5s)</option>
                    <option value="2000" data-i18n="fast">Fast (2s)</option>
                    <option value="1500" data-i18n="very-fast">Very Fast (1.5s)</option>
                </select>
            </div>

            <div class="control-group">
                <label for="sessionTime" data-i18n="session">Session:</label>
                <select id="sessionTime">
                    <option value="5" data-i18n="5-minutes">5 minutes</option>
                    <option value="10" data-i18n="10-minutes">10 minutes</option>
                    <option value="15" data-i18n="15-minutes">15 minutes</option>
                    <option value="20" selected data-i18n="20-minutes">20 minutes</option>
                    <option value="25" data-i18n="25-minutes">25 minutes</option>
                    <option value="30" data-i18n="30-minutes">30 minutes</option>
                </select>
            </div>

            <div class="control-group">
                <label for="autoLevel" data-i18n="auto-level">Auto Level:</label>
                <select id="autoLevel">
                    <option value="off" data-i18n="off">Off</option>
                    <option value="on" selected data-i18n="on">On</option>
                </select>
            </div>
            
            <button id="testAudioBtn" data-i18n="test-audio">Test Audio</button>
            <button id="startBtn" data-i18n="start-game">Start Game</button>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>

        <div class="timer-display" id="timerDisplay" data-i18n="ready-to-start">Ready to start</div>

        <div class="game-area">
            <div class="instructions" id="instructions" data-i18n="instructions">
                Press Start to begin training. Match visual positions and audio letters from N steps back.
            </div>
            
            <div class="audio-indicator" id="audioIndicator">â™ª</div>
            
            <div class="grid" id="grid">
                <div class="square" data-pos="0"></div>
                <div class="square" data-pos="1"></div>
                <div class="square" data-pos="2"></div>
                <div class="square" data-pos="3"></div>
                <div class="square" data-pos="4"></div>
                <div class="square" data-pos="5"></div>
                <div class="square" data-pos="6"></div>
                <div class="square" data-pos="7"></div>
                <div class="square" data-pos="8"></div>
            </div>

            <div class="response-buttons">
                <button class="response-btn visual" id="visualBtn" data-i18n="position-match">Position Match (A)</button>
                <button class="response-btn audio" id="audioBtn" data-i18n="audio-match">Audio Match (L)</button>
            </div>
        </div>

        <div class="stats">
            <div class="stat-box">
                <div class="stat-value" id="round">0</div>
                <div class="stat-label" data-i18n="rounds-completed">Rounds Completed</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="visualScore">0%</div>
                <div class="stat-label" data-i18n="position-accuracy">Position Accuracy</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="audioScore">0%</div>
                <div class="stat-label" data-i18n="audio-accuracy">Audio Accuracy</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="totalScore">0%</div>
                <div class="stat-label" data-i18n="total-accuracy">Total Accuracy</div>
            </div>
        </div>

        <div class="records-section">
            <div class="records-header">
                <div class="records-title" data-i18n="training-records">Training Records</div>
                <button class="clear-records-btn" id="clearRecordsBtn" data-i18n="clear-all">Clear All</button>
            </div>
            <div class="records-list" id="recordsList">
                <div class="no-records" data-i18n="no-records">No training sessions recorded yet. Complete a session to see your progress!</div>
            </div>
        </div>

        <!-- Feedback overlay -->
        <div class="feedback" id="feedback"></div>
        
        <!-- Level change notification -->
        <div class="level-change-notification" id="levelChangeNotification"></div>
    </div>

    <script>
        // Translation system
        const translations = {
            en: {
                // Page elements
                'title': 'Dual N-Back Training',
                'language': 'Language:',
                'lang-en': 'English',
                'lang-zh': 'ä¸­æ–‡',
                'n-level': 'N-Level:',
                '1-back': '1-Back',
                '2-back': '2-Back', 
                '3-back': '3-Back',
                '4-back': '4-Back',
                '5-back': '5-Back',
                '6-back': '6-Back',
                '7-back': '7-Back',
                '8-back': '8-Back',
                '9-back': '9-Back',
                '10-back': '10-Back',
                '11-back': '11-Back',
                '12-back': '12-Back',
                'speed': 'Speed:',
                'slow': 'Slow (3s)',
                'normal': 'Normal (2.5s)',
                'fast': 'Fast (2s)',
                'very-fast': 'Very Fast (1.5s)',
                'session': 'Session:',
                '5-minutes': '5 minutes',
                '10-minutes': '10 minutes',
                '15-minutes': '15 minutes',
                '20-minutes': '20 minutes',
                '25-minutes': '25 minutes',
                '30-minutes': '30 minutes',
                'auto-level': 'Auto Level:',
                'off': 'Off',
                'on': 'On',
                'test-audio': 'Test Audio',
                'start-game': 'Start Game',
                'stop-game': 'Stop Game',
                'instructions': 'Press Start to begin training. Match visual positions and audio letters from N steps back.',
                'position-match': 'Position Match (A)',
                'audio-match': 'Audio Match (L)',
                'rounds-completed': 'Rounds Completed',
                'position-accuracy': 'Position Accuracy',
                'audio-accuracy': 'Audio Accuracy',
                'total-accuracy': 'Total Accuracy',
                'training-records': 'Training Records',
                'clear-all': 'Clear All',
                'no-records': 'No training sessions recorded yet. Complete a session to see your progress!',
                
                // Dynamic messages
                'ready-to-start': 'Ready to start',
                'training-in-progress': '%s-Back Training in Progress...',
                'session-complete': 'Session Complete!',
                'training-complete': 'Training Complete! %s rounds completed. Total Score: %s%',
                'game-stopped': 'Game stopped. Press Start to begin training.',
                'minutes-remaining': '%s:%s remaining',
                'level-up': 'Level Up! Now playing %s-Back',
                'level-down': 'Level Down: Now playing %s-Back',
                
                // Records
                'back-suffix': '-Back',
                'min-suffix': 'min',
                'rounds': 'rounds',
                'pos-short': 'Pos',
                'audio-short': 'Audio',
                'total-short': 'Total',
                'auto-short': 'Auto',
                'manual-short': 'Manual'
            },
            zh: {
                // Page elements
                'title': 'åŒé‡ N è¿žè®­ç»ƒ',
                'language': 'è¯­è¨€ï¼š',
                'lang-en': 'English',
                'lang-zh': 'ä¸­æ–‡',
                'n-level': 'N çº§åˆ«ï¼š',
                '1-back': '1è¿ž',
                '2-back': '2è¿ž',
                '3-back': '3è¿ž',
                '4-back': '4è¿ž',
                '5-back': '5è¿ž',
                '6-back': '6è¿ž',
                '7-back': '7è¿ž',
                '8-back': '8è¿ž',
                '9-back': '9è¿ž',
                '10-back': '10è¿ž',
                '11-back': '11è¿ž',
                '12-back': '12è¿ž',
                'speed': 'é€Ÿåº¦ï¼š',
                'slow': 'æ…¢ (3ç§’)',
                'normal': 'æ­£å¸¸ (2.5ç§’)',
                'fast': 'å¿« (2ç§’)',
                'very-fast': 'å¾ˆå¿« (1.5ç§’)',
                'session': 'è®­ç»ƒæ—¶é•¿ï¼š',
                '5-minutes': '5åˆ†é’Ÿ',
                '10-minutes': '10åˆ†é’Ÿ',
                '15-minutes': '15åˆ†é’Ÿ',
                '20-minutes': '20åˆ†é’Ÿ',
                '25-minutes': '25åˆ†é’Ÿ',
                '30-minutes': '30åˆ†é’Ÿ',
                'auto-level': 'è‡ªåŠ¨è°ƒçº§ï¼š',
                'off': 'å…³é—­',
                'on': 'å¼€å¯',
                'test-audio': 'æµ‹è¯•éŸ³é¢‘',
                'start-game': 'å¼€å§‹æ¸¸æˆ',
                'stop-game': 'åœæ­¢æ¸¸æˆ',
                'instructions': 'æŒ‰å¼€å§‹é”®å¼€å§‹è®­ç»ƒã€‚åŒ¹é… N æ­¥å‰çš„è§†è§‰ä½ç½®å’ŒéŸ³é¢‘å­—æ¯ã€‚',
                'position-match': 'ä½ç½®åŒ¹é… (A)',
                'audio-match': 'éŸ³é¢‘åŒ¹é… (L)',
                'rounds-completed': 'å·²å®Œæˆè½®æ•°',
                'position-accuracy': 'ä½ç½®å‡†ç¡®çŽ‡',
                'audio-accuracy': 'éŸ³é¢‘å‡†ç¡®çŽ‡',
                'total-accuracy': 'æ€»å‡†ç¡®çŽ‡',
                'training-records': 'è®­ç»ƒè®°å½•',
                'clear-all': 'æ¸…é™¤å…¨éƒ¨',
                'no-records': 'å°šæ— è®­ç»ƒè®°å½•ã€‚å®Œæˆä¸€æ¬¡è®­ç»ƒåŽå³å¯æŸ¥çœ‹è¿›å±•ï¼',
                
                // Dynamic messages
                'ready-to-start': 'å‡†å¤‡å¼€å§‹',
                'training-in-progress': '%sè¿žè®­ç»ƒè¿›è¡Œä¸­...',
                'session-complete': 'è®­ç»ƒå®Œæˆï¼',
                'training-complete': 'è®­ç»ƒå®Œæˆï¼å®Œæˆäº† %s è½®è®­ç»ƒã€‚æ€»åˆ†ï¼š%s%',
                'game-stopped': 'æ¸¸æˆå·²åœæ­¢ã€‚æŒ‰å¼€å§‹é”®å¼€å§‹è®­ç»ƒã€‚',
                'minutes-remaining': 'å‰©ä½™ %s:%s',
                'level-up': 'å‡çº§ï¼çŽ°åœ¨è¿›è¡Œ %sè¿ž',
                'level-down': 'é™çº§ï¼šçŽ°åœ¨è¿›è¡Œ %sè¿ž',
                
                // Records
                'back-suffix': 'è¿ž',
                'min-suffix': 'åˆ†é’Ÿ',
                'rounds': 'è½®',
                'pos-short': 'ä½ç½®',
                'audio-short': 'éŸ³é¢‘',
                'total-short': 'æ€»è®¡',
                'auto-short': 'è‡ªåŠ¨',
                'manual-short': 'æ‰‹åŠ¨'
            }
        };

        // Translation helper
        class I18n {
            constructor() {
                this.currentLang = localStorage.getItem('dualnback-lang') || 'en';
                this.updateLanguage();
            }

            t(key, ...args) {
                let text = translations[this.currentLang][key] || translations['en'][key] || key;
                
                // Simple string formatting - replace %s with arguments
                if (args.length > 0) {
                    args.forEach((arg, index) => {
                        text = text.replace('%s', arg);
                    });
                }
                
                return text;
            }

            setLanguage(lang) {
                this.currentLang = lang;
                localStorage.setItem('dualnback-lang', lang);
                this.updateLanguage();
            }

            updateLanguage() {
                // Update all elements with data-i18n attributes
                document.querySelectorAll('[data-i18n]').forEach(element => {
                    const key = element.getAttribute('data-i18n');
                    element.textContent = this.t(key);
                });
                
                // Update page title
                document.title = this.t('title');
            }
        }

        class DualNBack {
            constructor() {
                // Initialize translation system
                this.i18n = new I18n();
                
                this.nLevel = 2;
                this.speed = 2500;
                this.sessionTime = 20; // minutes
                this.autoLevel = true; // Auto level up enabled by default
                this.isRunning = false;
                this.round = 0;
                
                // Auto level up settings
                this.levelUpThreshold = 80; // % accuracy needed to level up
                this.levelDownThreshold = 60; // % accuracy needed to level down
                this.minTrialsForLevelChange = 15; // minimum trials before considering level change
                this.recentTrials = []; // Track recent performance for auto level decisions
                
                // Timer properties
                this.sessionStartTime = null;
                this.sessionDuration = 0; // in milliseconds
                this.timerInterval = null;
                
                this.sequence = [];
                this.visualResponses = [];
                this.audioResponses = [];
                
                this.audioLetters = ['C', 'H', 'K', 'L', 'Q', 'R', 'S', 'T'];
                
                // Stats
                this.visualCorrect = 0;
                this.audioCorrect = 0;
                this.visualTotal = 0;
                this.audioTotal = 0;
                
                // Records system
                this.trainingRecords = this.loadRecords();
                
                this.initializeElements();
                this.setupEventListeners();
                this.createAudioContext();
                this.displayRecords();
            }

            initializeElements() {
                this.elements = {
                    language: document.getElementById('language'),
                    nLevel: document.getElementById('nLevel'),
                    speed: document.getElementById('speed'),
                    sessionTime: document.getElementById('sessionTime'),
                    autoLevel: document.getElementById('autoLevel'),
                    startBtn: document.getElementById('startBtn'),
                    testAudioBtn: document.getElementById('testAudioBtn'),
                    clearRecordsBtn: document.getElementById('clearRecordsBtn'),
                    grid: document.getElementById('grid'),
                    squares: document.querySelectorAll('.square'),
                    audioIndicator: document.getElementById('audioIndicator'),
                    instructions: document.getElementById('instructions'),
                    visualBtn: document.getElementById('visualBtn'),
                    audioBtn: document.getElementById('audioBtn'),
                    progressFill: document.getElementById('progressFill'),
                    timerDisplay: document.getElementById('timerDisplay'),
                    feedback: document.getElementById('feedback'),
                    recordsList: document.getElementById('recordsList'),
                    levelChangeNotification: document.getElementById('levelChangeNotification'),
                    
                    // Stats
                    round: document.getElementById('round'),
                    visualScore: document.getElementById('visualScore'),
                    audioScore: document.getElementById('audioScore'),
                    totalScore: document.getElementById('totalScore')
                };
                
                // Set language selector to current language
                this.elements.language.value = this.i18n.currentLang;
            }

            setupEventListeners() {
                this.elements.startBtn.addEventListener('click', () => this.toggleGame());
                this.elements.testAudioBtn.addEventListener('click', () => this.testAudio());
                this.elements.clearRecordsBtn.addEventListener('click', () => this.clearRecords());
                this.elements.visualBtn.addEventListener('click', () => this.recordResponse('visual'));
                this.elements.audioBtn.addEventListener('click', () => this.recordResponse('audio'));
                
                // Language change listener
                this.elements.language.addEventListener('change', (e) => {
                    this.i18n.setLanguage(e.target.value);
                    this.updateTimerDisplay(); // Update timer text immediately
                    this.displayRecords(); // Update records display
                });
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.key.toLowerCase() === 'a') this.recordResponse('visual');
                    if (e.key.toLowerCase() === 'l') this.recordResponse('audio');
                    if (e.key === ' ') {
                        e.preventDefault();
                        this.toggleGame();
                    }
                });

                this.elements.nLevel.addEventListener('change', (e) => {
                    this.nLevel = parseInt(e.target.value);
                });

                this.elements.speed.addEventListener('change', (e) => {
                    this.speed = parseInt(e.target.value);
                });

                this.elements.sessionTime.addEventListener('change', (e) => {
                    this.sessionTime = parseInt(e.target.value);
                });

                this.elements.autoLevel.addEventListener('change', (e) => {
                    this.autoLevel = e.target.value === 'on';
                    console.log('Auto level up:', this.autoLevel ? 'enabled' : 'disabled');
                });
            }

            testAudio() {
                // Initialize audio context if needed
                if (!this.audioContext) {
                    try {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        console.log('Audio context created for test');
                    } catch (error) {
                        console.error('Failed to create audio context for test:', error);
                        alert('Audio not supported in this browser');
                        return;
                    }
                }

                // Resume audio context
                if (this.audioContext.state === 'suspended') {
                    this.audioContext.resume().then(() => {
                        console.log('Audio context resumed for test');
                        this.playTestSounds();
                    }).catch(error => {
                        console.error('Failed to resume audio context:', error);
                        alert('Audio context could not be resumed');
                    });
                } else {
                    this.playTestSounds();
                }
            }

            playTestSounds() {
                console.log('Playing test sounds...');
                
                // Play correct sound
                setTimeout(() => {
                    console.log('Testing correct sound...');
                    this.playFeedbackSound(true);
                }, 100);
                
                // Play incorrect sound
                setTimeout(() => {
                    console.log('Testing incorrect sound...');
                    this.playFeedbackSound(false);
                }, 800);
                
                // Test letter sounds with speech synthesis
                const testLetters = ['C', 'H', 'K', 'L'];
                testLetters.forEach((letter, index) => {
                    setTimeout(() => {
                        console.log(`Testing letter sound: ${letter}`);
                        this.playTone(letter);
                    }, 1500 + (index * 800));
                });
            }

            createAudioContext() {
                // Don't create audio context immediately - wait for user interaction
                this.audioContext = null;
                this.useSpeech = true; // Enable speech synthesis by default
                
                // More distinct frequency mapping for better differentiation
                this.letterFrequencies = {
                    'C': 200, 'H': 280, 'K': 360, 'L': 440,
                    'Q': 520, 'R': 600, 'S': 680, 'T': 760
                };
                
                // Initialize speech synthesis
                this.setupVoice();
                
                console.log('Audio context initialization deferred until user interaction, speech synthesis enabled');
            }

            setupVoice() {
                if (!('speechSynthesis' in window)) {
                    console.log('Speech synthesis not supported, using fallback tones');
                    this.useSpeech = false;
                    return;
                }

                const voices = speechSynthesis.getVoices();
                
                if (voices.length === 0) {
                    // Voices not loaded yet, set up listener
                    speechSynthesis.onvoiceschanged = () => {
                        const newVoices = speechSynthesis.getVoices();
                        this.selectBestVoice(newVoices);
                    };
                } else {
                    this.selectBestVoice(voices);
                }
            }

            selectBestVoice(voices) {
                // Prefer English voices, prioritize system voices
                this.voice = voices.find(voice => 
                    voice.lang.startsWith('en') && voice.localService
                ) || voices.find(voice => 
                    voice.lang.startsWith('en')
                ) || voices[0];
                
                if (this.voice) {
                    console.log(`Selected voice: ${this.voice.name} (${this.voice.lang})`);
                } else {
                    console.log('No suitable voice found, using fallback tones');
                    this.useSpeech = false;
                }
            }

            playTone(letter) {
                console.log(`Playing tone for letter: ${letter}, useSpeech: ${this.useSpeech}`);
                
                if (this.useSpeech && 'speechSynthesis' in window) {
                    try {
                        // Map letters to phonetic pronunciation to avoid "capital X" 
                        const letterPhonetics = {
                            'C': 'see',
                            'H': 'aitch', 
                            'K': 'kay',
                            'L': 'ell',
                            'Q': 'cue',
                            'R': 'are', 
                            'S': 'ess',
                            'T': 'tee'
                        };
                        
                        const textToSpeak = letterPhonetics[letter] || letter.toLowerCase();
                        const utterance = new SpeechSynthesisUtterance(textToSpeak);
                        
                        if (this.voice) {
                            utterance.voice = this.voice;
                            console.log(`Using voice: ${this.voice.name}`);
                        } else {
                            console.log('No specific voice set, using default');
                        }
                        
                        utterance.rate = 1.0; // Slower for clarity
                        utterance.pitch = 1.0;
                        utterance.volume = 0.9; // Higher volume
                        
                        // Add event listeners for debugging
                        utterance.onstart = () => console.log(`Started speaking: ${letter}`);
                        utterance.onend = () => console.log(`Finished speaking: ${letter}`);
                        utterance.onerror = (event) => {
                            console.error('Speech synthesis error:', event.error);
                            // Fallback to tones on error
                            this.playFallbackTone(letter);
                        };
                        
                        // Cancel any ongoing speech and speak the letter
                        speechSynthesis.cancel();
                        speechSynthesis.speak(utterance);
                        
                    } catch (error) {
                        console.error('Error with speech synthesis:', error);
                        this.playFallbackTone(letter);
                    }
                } else {
                    this.playFallbackTone(letter);
                }
            }

            playFallbackTone(letter) {
                console.log(`Playing fallback tone for letter: ${letter}`);
                
                // Fallback to improved Web Audio API tones
                if (!this.audioContext) {
                    console.log('No audio context available for fallback');
                    return;
                }
                
                try {
                    const frequency = this.letterFrequencies[letter];
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    // Use sawtooth wave for more distinctive sound
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                    
                    // Envelope for more natural sound
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.3, this.audioContext.currentTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.6);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.6);
                } catch (error) {
                    console.error('Error playing fallback tone:', error);
                }
            }

            playFeedbackSound(isCorrect) {
                console.log(`Playing feedback sound: ${isCorrect ? 'correct' : 'incorrect'}`);
                
                if (!this.audioContext) {
                    console.error('No audio context available');
                    // Fallback to a simple console beep or alert
                    if (isCorrect) {
                        console.log('ðŸ”Š CORRECT!');
                    } else {
                        console.log('ðŸ”Š INCORRECT!');
                    }
                    return;
                }
                
                try {
                    // Resume audio context immediately if needed
                    if (this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    if (isCorrect) {
                        // High, pleasant chime for correct responses
                        oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(1000, this.audioContext.currentTime + 0.1);
                        oscillator.type = 'sine';
                    } else {
                        // Low, brief buzz for incorrect responses
                        oscillator.frequency.setValueAtTime(200, this.audioContext.currentTime);
                        oscillator.type = 'square';
                    }
                    
                    // Quick envelope for immediate sound
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.5, this.audioContext.currentTime + 0.005); // Higher volume
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + (isCorrect ? 0.15 : 0.08));
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + (isCorrect ? 0.15 : 0.08));
                    
                    console.log('Feedback sound played successfully');
                } catch (error) {
                    console.error('Error playing feedback sound:', error);
                }
            }

            updateStatsRealTime() {
                const accuracy = this.calculateAccuracy();
                
                this.elements.visualScore.textContent = `${accuracy.visual}%`;
                this.elements.audioScore.textContent = `${accuracy.audio}%`;
                this.elements.totalScore.textContent = `${accuracy.total}%`;
            }

            playNotReadySound() {
                if (!this.audioContext) return;
                
                // Resume audio context immediately if needed
                if (this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                // Soft, low tone for "not ready"
                oscillator.frequency.setValueAtTime(300, this.audioContext.currentTime);
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.15, this.audioContext.currentTime + 0.005);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.12);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.12);
            }

            playTooEarlySound() {
                if (!this.audioContext) return;
                
                // Resume audio context immediately if needed
                if (this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                // Double beep for "too early" - need to wait for N rounds
                oscillator.frequency.setValueAtTime(400, this.audioContext.currentTime);
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.2, this.audioContext.currentTime + 0.005);
                gainNode.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + 0.06);
                gainNode.gain.linearRampToValueAtTime(0.2, this.audioContext.currentTime + 0.08);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.15);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.15);
            }

            playErrorSound() {
                if (!this.audioContext) return;
                
                // Resume audio context immediately if needed
                if (this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                // Brief error tone
                oscillator.frequency.setValueAtTime(150, this.audioContext.currentTime);
                oscillator.type = 'sawtooth';
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.2, this.audioContext.currentTime + 0.005);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.08);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.08);
            }

            toggleGame() {
                if (this.isRunning) {
                    this.stopGame();
                } else {
                    this.startGame();
                }
            }

            startGame() {
                this.isRunning = true;
                this.round = 0;
                this.sequence = [];
                this.visualResponses = [];
                this.audioResponses = [];
                
                this.visualCorrect = 0;
                this.audioCorrect = 0;
                this.visualTotal = 0;
                this.audioTotal = 0;
                
                // Reset auto level tracking
                this.recentTrials = [];
                
                // Get current settings
                this.nLevel = parseInt(this.elements.nLevel.value);
                this.autoLevel = this.elements.autoLevel.value === 'on';
                
                // Initialize audio context if needed (user interaction required)
                if (!this.audioContext) {
                    try {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        console.log('Audio context initialized on game start');
                    } catch (error) {
                        console.error('Failed to initialize audio context:', error);
                        this.audioContext = null;
                    }
                }
                
                // Resume audio context
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume().then(() => {
                        console.log('Audio context resumed');
                    }).catch(error => {
                        console.error('Failed to resume audio context:', error);
                        this.audioContext = null;
                    });
                }
                
                // Set up timer
                this.sessionDuration = this.sessionTime * 60 * 1000; // convert to milliseconds
                this.sessionStartTime = Date.now();
                
                this.elements.startBtn.textContent = this.i18n.t('stop-game');
                this.elements.instructions.textContent = this.i18n.t('training-in-progress', this.nLevel);
                this.elements.grid.classList.add('active');
                
                this.enableResponseButtons();
                this.startTimer();
                this.nextRound();
            }

            startTimer() {
                this.updateTimer();
                this.timerInterval = setInterval(() => {
                    this.updateTimer();
                }, 1000);
            }

            updateTimer() {
                if (!this.sessionStartTime) return;
                
                const elapsed = Date.now() - this.sessionStartTime;
                const remaining = Math.max(0, this.sessionDuration - elapsed);
                
                if (remaining === 0) {
                    this.endSession();
                    return;
                }
                
                const minutes = Math.floor(remaining / 60000);
                const seconds = Math.floor((remaining % 60000) / 1000);
                
                this.elements.timerDisplay.textContent = this.i18n.t('minutes-remaining', minutes, seconds.toString().padStart(2, '0'));
                
                // Update progress bar based on time
                const progress = ((this.sessionDuration - remaining) / this.sessionDuration) * 100;
                this.elements.progressFill.style.width = `${progress}%`;
            }

            updateTimerDisplay() {
                // Helper method to update timer display when language changes
                if (this.sessionStartTime) {
                    this.updateTimer();
                } else {
                    this.elements.timerDisplay.textContent = this.i18n.t('ready-to-start');
                }
            }

            endSession() {
                this.isRunning = false;
                clearInterval(this.timerInterval);
                clearTimeout(this.currentTimeout);
                
                this.elements.startBtn.textContent = this.i18n.t('start-game');
                this.elements.timerDisplay.textContent = this.i18n.t('session-complete');
                
                const accuracy = this.calculateAccuracy();
                this.elements.instructions.textContent = this.i18n.t('training-complete', this.round, accuracy.total);
                
                this.elements.grid.classList.remove('active');
                this.disableResponseButtons();
                this.updateStats();
                
                // Save training record
                this.saveTrainingRecord(accuracy);
                
                // Reset timer display after a few seconds
                setTimeout(() => {
                    this.elements.timerDisplay.textContent = this.i18n.t('ready-to-start');
                    this.elements.progressFill.style.width = '0%';
                }, 3000);
            }

            // Records Management
            loadRecords() {
                try {
                    const stored = localStorage.getItem('dualNBackRecords');
                    const records = stored ? JSON.parse(stored) : [];
                    console.log('Loaded records:', records.length); // Debug log
                    return records;
                } catch (error) {
                    console.error('Error loading records:', error);
                    return [];
                }
            }

            saveRecords() {
                try {
                    localStorage.setItem('dualNBackRecords', JSON.stringify(this.trainingRecords));
                    console.log('Records saved to localStorage'); // Debug log
                } catch (error) {
                    console.error('Error saving records:', error);
                }
            }

            saveTrainingRecord(accuracy) {
                const actualDuration = this.sessionStartTime ? 
                    Math.round((Date.now() - this.sessionStartTime) / 1000 / 60) : 0; // minutes
                
                const record = {
                    date: new Date().toLocaleString(),
                    nLevel: this.nLevel,
                    plannedTime: this.sessionTime,
                    actualTime: actualDuration,
                    rounds: this.round,
                    positionAccuracy: accuracy.visual,
                    audioAccuracy: accuracy.audio,
                    totalAccuracy: accuracy.total,
                    speed: this.speed,
                    autoLevel: this.autoLevel
                };

                console.log('Saving training record:', record); // Debug log

                this.trainingRecords.unshift(record); // Add to beginning
                
                // Keep only last 50 records
                if (this.trainingRecords.length > 50) {
                    this.trainingRecords = this.trainingRecords.slice(0, 50);
                }

                this.saveRecords();
                this.displayRecords();
                
                console.log('Records saved. Total records:', this.trainingRecords.length); // Debug log
            }

            displayRecords() {
                const recordsList = this.elements.recordsList;
                
                if (this.trainingRecords.length === 0) {
                    recordsList.innerHTML = `<div class="no-records" data-i18n="no-records">${this.i18n.t('no-records')}</div>`;
                    return;
                }

                recordsList.innerHTML = this.trainingRecords.map(record => `
                    <div class="record-item">
                        <div class="record-date">${record.date}</div>
                        <div class="record-details">
                            <div><strong>${record.nLevel}</strong>${this.i18n.t('back-suffix')}</div>
                            <div>${record.actualTime || record.sessionTime || record.plannedTime}${this.i18n.t('min-suffix')}</div>
                            <div>${record.rounds} ${this.i18n.t('rounds')}</div>
                            <div>${this.i18n.t('pos-short')}: ${record.positionAccuracy}%</div>
                            <div>${this.i18n.t('audio-short')}: ${record.audioAccuracy}%</div>
                            <div><strong>${this.i18n.t('total-short')}: ${record.totalAccuracy}%</strong></div>
                            ${record.autoLevel ? `<div style="color: #4CAF50;">${this.i18n.t('auto-short')}</div>` : `<div style="color: #FFA726;">${this.i18n.t('manual-short')}</div>`}
                        </div>
                    </div>
                `).join('');
                
                console.log('Records displayed:', this.trainingRecords.length); // Debug log
            }

            clearRecords() {
                if (confirm('Are you sure you want to clear all training records? This cannot be undone.')) {
                    this.trainingRecords = [];
                    this.saveRecords();
                    this.displayRecords();
                }
            }

            stopGame() {
                if (!this.isRunning) return;
                
                this.isRunning = false;
                clearTimeout(this.currentTimeout);
                clearInterval(this.timerInterval);
                
                // Save record if we've completed at least a few rounds
                if (this.round >= this.nLevel) {
                    const accuracy = this.calculateAccuracy();
                    this.saveTrainingRecord(accuracy);
                }
                
                this.elements.startBtn.textContent = this.i18n.t('start-game');
                this.elements.instructions.textContent = this.i18n.t('game-stopped');
                this.elements.timerDisplay.textContent = this.i18n.t('ready-to-start');
                this.elements.grid.classList.remove('active');
                this.elements.progressFill.style.width = '0%';
                this.clearActiveSquares();
                
                this.disableResponseButtons();
                this.updateStats();
            }

            nextRound() {
                if (!this.isRunning) {
                    return;
                }

                this.round++;
                
                // Generate new stimuli
                const visualPos = Math.floor(Math.random() * 9);
                const audioLetter = this.audioLetters[Math.floor(Math.random() * this.audioLetters.length)];
                
                this.sequence.push({ visual: visualPos, audio: audioLetter });
                
                // Clear previous responses for this round
                this.visualResponses[this.round - 1] = false;
                this.audioResponses[this.round - 1] = false;
                
                // Show stimuli
                this.showStimuli(visualPos, audioLetter);
                
                // Schedule next round
                this.currentTimeout = setTimeout(() => {
                    this.nextRound();
                }, this.speed);
            }

            showStimuli(visualPos, audioLetter) {
                // Clear previous
                this.clearActiveSquares();
                
                // Show visual
                this.elements.squares[visualPos].classList.add('active');
                
                // Resume audio context if needed (for user interaction requirement)
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
                
                // Play the letter sound (audio only, no visual indicator)
                this.playTone(audioLetter);
                
                // Hide visual stimuli after short display
                setTimeout(() => {
                    this.clearActiveSquares();
                }, 500);
                
                this.elements.round.textContent = this.round;
            }

            clearActiveSquares() {
                this.elements.squares.forEach(square => {
                    square.classList.remove('active', 'clicked');
                });
            }

            recordResponse(type) {
                if (!this.isRunning) {
                    // Play a subtle "not ready" sound
                    this.playNotReadySound();
                    return;
                }
                
                if (this.round < this.nLevel) {
                    // Play a "too early" sound - need to wait for N rounds
                    this.playTooEarlySound();
                    return;
                }
                
                const currentIndex = this.round - 1;
                const targetIndex = currentIndex - this.nLevel;
                
                // Make sure we have valid indices
                if (currentIndex < 0 || targetIndex < 0 || 
                    currentIndex >= this.sequence.length || 
                    targetIndex >= this.sequence.length) {
                    // Play error sound for invalid state
                    this.playErrorSound();
                    return;
                }
                
                // Check if this is a correct match RIGHT NOW
                let isCorrect = false;
                if (type === 'visual') {
                    const visualMatch = this.sequence[currentIndex].visual === this.sequence[targetIndex].visual;
                    isCorrect = visualMatch;
                    this.visualResponses[currentIndex] = true;
                    this.elements.visualBtn.classList.add('pulse');
                    setTimeout(() => this.elements.visualBtn.classList.remove('pulse'), 500);
                } else {
                    const audioMatch = this.sequence[currentIndex].audio === this.sequence[targetIndex].audio;
                    isCorrect = audioMatch;
                    this.audioResponses[currentIndex] = true;
                    this.elements.audioBtn.classList.add('pulse');
                    setTimeout(() => this.elements.audioBtn.classList.remove('pulse'), 500);
                }
                
                // Give IMMEDIATE feedback based on current comparison
                this.showFeedback(isCorrect, type);
                
                // Track for auto level up after enough rounds
                if (this.autoLevel && this.round >= this.nLevel + this.minTrialsForLevelChange) {
                    this.checkAutoLevelUp();
                }
            }

            showFeedback(isCorrect, type) {
                // Immediate audio feedback - plays instantly when button is pressed
                this.playFeedbackSound(isCorrect);
                
                // Update accuracy stats in real-time
                this.updateStatsRealTime();
            }

            checkAutoLevelUp() {
                if (!this.autoLevel) return;

                // Calculate current overall accuracy using the existing method
                const accuracy = this.calculateAccuracy();
                const totalAccuracy = accuracy.total;

                console.log(`Auto level check: ${totalAccuracy}% accuracy at round ${this.round}`);

                // Level up if performance is good and not at max level
                if (totalAccuracy >= this.levelUpThreshold && this.nLevel < 12) {
                    this.levelUp();
                    return;
                }
                // Level down if performance is poor and not at min level  
                if (totalAccuracy < this.levelDownThreshold && this.nLevel > 1) {
                    this.levelDown();
                    return;
                }
            }

            trackTrialForAutoLevel(isCorrect, type) {
                // Add this trial to recent trials
                this.recentTrials.push({
                    correct: isCorrect,
                    type: type,
                    round: this.round
                });

                // Keep only recent trials for level decisions
                const maxTrials = Math.max(this.minTrialsForLevelChange * 2, 30);
                if (this.recentTrials.length > maxTrials) {
                    this.recentTrials = this.recentTrials.slice(-maxTrials);
                }

                // Check if we should change level (only after minimum trials)
                if (this.recentTrials.length >= this.minTrialsForLevelChange) {
                    this.checkLevelChange();
                }
            }

            checkLevelChange() {
                if (!this.autoLevel) return;

                // Calculate recent accuracy
                const recentTrialsToAnalyze = this.recentTrials.slice(-this.minTrialsForLevelChange);
                const totalTrials = recentTrialsToAnalyze.length;
                const correctTrials = recentTrialsToAnalyze.filter(trial => trial.correct).length;
                const accuracy = (correctTrials / totalTrials) * 100;

                console.log(`Auto level check: ${accuracy.toFixed(1)}% accuracy over ${totalTrials} trials`);

                // Level up if performance is good and not at max level
                if (accuracy >= this.levelUpThreshold && this.nLevel < 12) {
                    this.levelUp();
                }
                // Level down if performance is poor and not at min level  
                else if (accuracy < this.levelDownThreshold && this.nLevel > 1) {
                    this.levelDown();
                }
            }

            showLevelChangeNotification(message, isLevelDown) {
                const notification = this.elements.levelChangeNotification;
                notification.textContent = message;
                notification.classList.remove('level-down');
                
                if (isLevelDown) {
                    notification.classList.add('level-down');
                }
                
                notification.classList.add('show');
                
                // Hide after 3 seconds
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 3000);
            }

            levelUp() {
                const oldLevel = this.nLevel;
                this.nLevel++;
                this.elements.nLevel.value = this.nLevel;
                
                // Clear recent trials to avoid immediate level changes
                this.recentTrials = [];
                
                // Show notification
                this.showLevelChangeNotification(this.i18n.t('level-up', this.nLevel), false);
                
                console.log(`Auto level up: ${oldLevel}-Back â†’ ${this.nLevel}-Back`);
            }

            levelDown() {
                const oldLevel = this.nLevel;
                this.nLevel--;
                this.elements.nLevel.value = this.nLevel;
                
                // Clear recent trials to avoid immediate level changes
                this.recentTrials = [];
                
                // Show notification
                this.showLevelChangeNotification(this.i18n.t('level-down', this.nLevel), true);
                
                console.log(`Auto level down: ${oldLevel}-Back â†’ ${this.nLevel}-Back`);
            }

            calculateAccuracy() {
                let visualCorrect = 0, audioCorrect = 0;
                let visualTotal = 0, audioTotal = 0;
                
                for (let i = this.nLevel; i < this.sequence.length; i++) {
                    const targetIndex = i - this.nLevel;
                    
                    // Visual matching
                    const visualMatch = this.sequence[i].visual === this.sequence[targetIndex].visual;
                    const visualResponse = this.visualResponses[i] || false;
                    
                    if (visualMatch === visualResponse) visualCorrect++;
                    visualTotal++;
                    
                    // Audio matching
                    const audioMatch = this.sequence[i].audio === this.sequence[targetIndex].audio;
                    const audioResponse = this.audioResponses[i] || false;
                    
                    if (audioMatch === audioResponse) audioCorrect++;
                    audioTotal++;
                }
                
                return {
                    visual: visualTotal > 0 ? Math.round((visualCorrect / visualTotal) * 100) : 0,
                    audio: audioTotal > 0 ? Math.round((audioCorrect / audioTotal) * 100) : 0,
                    total: (visualTotal + audioTotal) > 0 ? Math.round(((visualCorrect + audioCorrect) / (visualTotal + audioTotal)) * 100) : 0
                };
            }

            updateStats() {
                const accuracy = this.calculateAccuracy();
                
                this.elements.visualScore.textContent = `${accuracy.visual}%`;
                this.elements.audioScore.textContent = `${accuracy.audio}%`;
                this.elements.totalScore.textContent = `${accuracy.total}%`;
            }

            updateProgress() {
                const progress = (this.round / this.maxRounds) * 100;
                this.elements.progressFill.style.width = `${progress}%`;
            }

            enableResponseButtons() {
                this.elements.visualBtn.classList.remove('disabled');
                this.elements.audioBtn.classList.remove('disabled');
            }

            disableResponseButtons() {
                this.elements.visualBtn.classList.add('disabled');
                this.elements.audioBtn.classList.add('disabled');
            }

            endGame() {
                this.isRunning = false;
                this.elements.startBtn.textContent = 'Start Game';
                
                const accuracy = this.calculateAccuracy();
                this.elements.instructions.textContent = `Training Complete! Total Score: ${accuracy.total}%`;
                
                this.elements.grid.classList.remove('active');
                this.disableResponseButtons();
                this.updateStats();
            }
        }

        // Initialize the game when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new DualNBack();
        });
    </script>
</body>
</html>